---
slug: category-functor
title: "[Category] Functor"
date: 2022-02-04
author: hobin-jeong
tags:
  - mathematics
  - category-theory
---


* 목차

  * [시작하면서...](#시작하면서...)
  * [Functor 정의](#functor-정의)
  * [Examples 1](#examples-1)
  * [Faithful, Full, Fully faithful functors](#faithful,-full,-fully-faithful-functors)
  * [Examples 2](#examples-2)
  * [마무리](#마무리)

## 시작하면서...

- - -

내 짧은 수학적 경험만으로도 알 수 있는 사실이 하나 있다. 수학에서는 보통  

1. 새로운 object를 소개하고 나면,
2. 그 대상의 sub-object를 살펴보고,  
3. 해당 object사이의 대응관계(보통은 함수)를 살펴본다.

Category theory에서도 마찬가지로, category가 무엇인지 정의하고 이에 대한 예를 살펴보았으니, 이제는 category 사이의 대응관계를 살펴볼 차례이다. 이러한 대응관계를 앞으로 `functor`라고 부르고자 한다. Category는 기본적으로 object와 morphism으로 이루어져 있으니, 두 카테고리 사이의 적절한 대응관계가 되려면 object끼리의 대응뿐만 아니라 morphism도 잘 옮겨야 할 것이다. 아래에서 정확한 정의를 살펴보도록 한다.

## Functor 정의

- - -

Category $$\mathcal{C}$$와 \( \mathcal{D} \)가 주어졌다고 하자. 이 때 `functor` \( F:\mathcal{C}\longrightarrow\mathcal{D} \)는 다음의 조건을 만족한다.:

1. the sets of objects 사이에서 map으로써 작용하여야 하고, 즉,

     $$
         F:Ob(\mathcal{C})\longrightarrow Ob(\mathcal{D}),\quad X\mapsto F(X)(=FX)
     $$
2. the sets of morphisms 사이에서도 구조를 보존하여아 한다. 즉, 각 ordered pair $$(X,Y)$$ of objects in $$\mathcal{C}$$에 대하여, map

     $$
         Hom*{\mathcal{C}}(X,Y)\longrightarrow Hom*{\mathcal{D}}(FX, FY)
     $$

     은 다음을 만족하여야 한다. (Functoriality):

     a) 각 $$X\in\mathcal{C}$$에 대하여 $$F(id*X)=id*{FX},$$

     b) morphism $$f:X\longrightarrow Y,:g:Y\longrightarrow Z$$에 대하여, 

     $$
         F(g\circ f)=Fg\circ Ff.
     $$

사실 위의 morphism의 대응을 보면 $$\mathcal{C}$$내에서의 morphism의 방향이 $$F$$를 통해 $$\mathcal{D}$$로 가도 그대로 유지된 것을 알 수 있는데, 이러한 functor를 `covariant functor`라고 한다. 이와는 반대로 morphism의 방향이 $$F$$를 통해 가면서 방향이 바뀌면, 즉 covariant functor $$F:\mathcal{C}\longrightarrow\mathcal{D}$$에 대해 functor $$\mathcal{C}^{op}\longrightarrow\mathcal{D}$$를 `contravariant functor`라고 부른다.

주어진 functor $$F:\mathcal{C}\longrightarrow\mathcal{D}$$에 대해 만약에 $$\mathcal{C}$$의 morphism $$f:X\longrightarrow Y$$가 isomorphism이라면, $$F(f)$$ 또한 isomorphism이다. 만약 역도 성립한다면, 이러한 functor는 `conservative`하다고 한다.

## Examples 1

- - -

간단한 Functor들을 살펴보자.

1. 임의의 category $$\mathcal{C}$$에 대해 identity functor $$id_{\mathcal{C}}:\mathcal{C}\longrightarrow\mathcal{C}$$.
2. 만약 $$\mathcal{C}$$가 여러 구조를 갖는 concrete category라면, 즉, $$\mathcal{C}=\mathtt{GRP},\mathtt{AB},\mathtt{RINGS},\mathtt{TOP},\ldots$$라면, functor

     $$
         U:\mathcal{C}\longrightarrow\mathtt{SETS}
     $$

     를 `forgetful functor` 라고 부른다. 원래 object가 갖고 있던 set-theoretic 성질이 functor를 타고 넘어오면서 마치 잊는 듯 하기 때문이다. 필요에 따라서는 해당 object의 모든 정보를 다 필요로 하지 않기 때문에, 이러한 구조의 functor는 상당히 흥미롭다. 이름도 누가 지었는진 몰라도 재치있게 잘 지은거 같다. 바로 생각해볼 수 있는 것은, 반드시 set-theoretic한 정보 이외의 모든 정보를 다 잊어버릴 필요는 없단 것이다. 즉, 더 많은 정보를 가진 object를 가진 category에서 더 적은 정보를 가지는 object를 가지는 category로 보내기만 한다면, 이는 모두 forgetful functor가 된다.
3. Ring $$A$$에 대해, functor

     $$
         F:\mathtt{SETS}\longrightarrow\mathtt{A-MOD}
     $$

     를 다음과 같이 정의한다.: 주어진 set $$S$$에 대해 $$F(S)$$를 free $$A$$-module generated by $$S$$. Morphism은 어떻게 대응이 될까? 만약 $$f:S\longrightarrow T$$가 set map이라면, 유일한 $$A$$-linear map $$F(f):F(S)\longrightarrow F(T),: F(f)(s):= f(s)$$로 대응된다.

## Faithful, Full, Fully faithful functors

- - -

집합론에서 함수를 배우고 나면 injective, surjective, bijective를 배우듯, functor에서도 이에 대응하는 개념이 존재한다.

주어진 functor $$F:\mathcal{C}\longrightarrow\mathcal{D}$$가 `faithful`(resp. `full`, `fully faithful`) 하다는 것은, 각 ordered pair $$(X,Y)$$ of objects of $$\mathcal{C}$$에 대하여, map

$$
    Hom*{\mathcal{C}}(X,Y)\longrightarrow Hom*{\mathcal{D}}(FX, FY)
$$

가 injective (resp. surjective, bijective) 라는 뜻이다.

위의 정의들은 morphism의 set간의 대응이 어떠냐에 따라 이름이 나뉘는걸 알 수 있다. Object간의 대응도 궁금한데, 다음의 정의도 있다. $$F$$가 `essentially surjective` 하다는 것은, 각 $$Y\in\mathcal{D}$$마다 $$F(X)\cong Y$$를 만족시키는 $$X\in\mathcal{C}$$가 존재하는 것을 뜻한다. 정확히 $$F(X)=Y$$이어야 하는 것은 아니어서 essentially 라는 단어가 더 붙은 듯 하다. 사실 대수학을 처음 공부할 때 꽤 불편했던 것 중 하나는 "같다"라는 단어가 사실은 isomorphism, 즉, 집합적인 같음을 벗어나 대수적인 같음을 뜻한다는 것이었다. 지금은 너무나 당연한 얘기지만... 여기서도 object로써 같으면 충분하다로 이해하면 크게 무리는 없어 보인다.

## Examples 2

- - -

1. Forgetful functor $$U:\mathtt{GRP}\longrightarrow\mathtt{SETS}$$는 faithful하지만 full은 아니다. 

   Faithful인 이유는 같은 underlying sets 사이에서 정의 된 두 개의 group homomorphism은 함숫값이 같다면 사실은 둘이 같아지기 때문이다. (즉, 이미 함수 레벨에서 맵핑이 끝났기 때문에 group homomorphism도 이를 따라 가는 것.)

   하지만 groups의 underlying sets으로 구성된 임의의 set map이 항상 group homomorphism은 아니기 때문에 full일 수는 없다.

   이 functor가 essentially surjective는 될까? 이 질문은 결국 임의의 set 위에 group의 연산을 줄 수 있는가? 라는 질문과 같은 말이다. 정답은 아니다. 이유는 허무하게도 공집합은 group이 될 수 없기 때문이다.
2. Inclusion functor $$U:\mathtt{AB}\longrightarrow\mathtt{GRP}$$은 fully faithful하지만 essentially surjective는 아니다.

   Fully faithful은 명확하다. Essentially surjective가 아닌 이유도 꽤 명확한데, 임의의 group이 abelian group은 아니기 때문이다.
3. 위에서 정의한 free functor $$F:\mathtt{SETS}\longrightarrow\mathtt{A-MOD}$$는 어떠한가?

   우선 $$F$$는 faithful이다. Set maps $$f:S\longrightarrow T$$와 $$g:S\longrightarrow T$$에 대하여 $$F(f)=F(g)$$라고 하면, the free module generated by $$S$$는 $$S$$를 갖고 있으니 모든 $$s\in S$$에 대해 $$F(f)(s)=F(g)(s)$$, 즉, $$f(s)=g(s)$$이어야 한다. 이는 곧 $$f=g$$를 뜻하므로 이로부터 $$F$$가 faithful임을 안다.

   그렇다면 full은 될까? 아니다. full이 되냐는 질문은 free modules 사이에서 정의된 $$A$$-linear map을 the set of generators 사이의 map으로 restriction 할 수 있는가와 같은데, set에는 기본적으로 연산이 없기 때문에, linear map에서 geenerator 위에서의 함숫값을 정해줄 때 연산이 섞이도록 정해주면 restriction 할 수 없게 된다. 예를 들어 간단히 식으로 본다면, $$s\mapsto t1+t2$$와 같은 linear map은 set map으로써 restriction이 불가하기 때문에, $$F$$는 full이 아니다.

   마지막으로 $$F$$는 essentially surjective일까? 이는 임의의 $$A$$-module이 free인가? 라는 질문과 동치일 것이다. 당연히 그럴리 없다. 그럼 언제 essentially surjective가 성립할까? 우리는 선형대수에서 모든 vector space는 basis를 가짐을 공부했었다. 즉, $$A$$가 field라면 이 때의 $$F$$는 essentially surjective가 된다.

## 마무리

- - -

오늘은 functor의 정의 및 그에 관련된 예시를 살펴보았다. 다음 포스팅에서는 언젠간 제대로 알고 싶다고 생각했었던 natural transformation 및 Yoneda lemma에 대해서 알아보도록 하겠다.