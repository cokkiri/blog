---
slug: text-decryption-using-mcmc-with-python
title: Text Decryption Using MCMC (with Python)
date: 2020-03-26
author: dohyungp
---
ì•ˆë…•í•˜ì„¸ìš”, ë°•ë„í˜•ì…ë‹ˆë‹¤.
í‹ˆí‹ˆíˆ R-Bloggerì—ì„œ ë©”ì¼ì„ í†µí•´ ë°›ì•„ë³´ëŠ” í¸ì¸ë°, ì¬ë°Œê²Œ ì½ì—ˆë˜ í¬ìŠ¤íŠ¸ì¸ <a href="https://www.r-bloggers.com/text-decryption-using-mcmc/">Text Decryption Using MCMC</a>ë¥¼ R ë²„ì „ì—ì„œ Pythonìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ì‘ì—…ì„ í•´ë´¤ìŠµë‹ˆë‹¤.

í•„ìš”í•œ íŒ¨í‚¤ì§€ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```py
import random
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
```

ì´ ê¸€ì—ì„œëŠ” ëŒ€ë¬¸ì ì•ŒíŒŒë²³ë“¤ë§Œ ì‚¬ìš©í•  ê²ƒì´ë¯€ë¡œ, LETTERSë¼ëŠ” ì•ŒíŒŒë²³ ëŒ€ë¬¸ì ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.

```py
LETTERS = [chr(c) for c in range(ord('A'), ord('Z') + 1)]
```

ì´ í›„ ì•ŒíŒŒë²³ ê°„ì˜ ì „ì´ ë¹ˆë„ë¥¼ ë‹´ê³  ìˆëŠ” Trasition Matrixë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ Trainsition Matrixë€, íŠ¹ì • ì•ŒíŒŒë²³ì—ì„œ ë‹¤ë¥¸ ì•ŒíŒŒë²³ìœ¼ë¡œ ê°ˆ ë¹ˆë„ë¥¼ ê³„ì‚°í•œ ê²ƒì„ ì´ì•¼ê¸°í•©ë‹ˆë‹¤(e.g QUEENì´ë¼ëŠ” ë‹¨ì–´ê°€ ë“¤ì–´ê°”ì„ ë•Œ, Q $\rightarrow$ Uì— í•´ë‹¹í•˜ëŠ” ë¹ˆë„ê°’ì„ ì—…ë°ì´íŠ¸). ê³µì‹ì ìœ¼ë¡œëŠ” <a href="https://en.wikipedia.org/wiki/Stochastic_matrix">Stochastic Matrix</a>ë¼ê³  í•©ë‹ˆë‹¤.

```py
trans_mat = {
    c1: {c2: 0 for c2 in LETTERS + ['']}
    for c1 in LETTERS + ['']
}
```

ì¤€ë¹„ê°€ ëë‚¬ìŠµë‹ˆë‹¤. ì´ì œ ì‹¤ì œ ë°ì´í„°ë¥¼ ê°€ì§€ê³ , ìœ„ì˜ `trans_mat`ë¥¼ ì—…ë°ì´íŠ¸í•´ì£¼ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤. ì €ëŠ” ê¸°ì¡´ ì˜ˆì œì— ì¶”ê°€ì ìœ¼ë¡œ <a href="https://github.com/dwyl/english-words">ì˜ì–´ ë‹¨ì–´ ëª©ë¡</a>ê³¼ <a href="http://www.gutenberg.org/">êµ¬í…ë² ë¥´í¬ í”„ë¡œì íŠ¸(Project Gutenberg)</a>ì—ì„œ ì´ìƒí•œ ë‚˜ë¼ì˜ ì•¨ë¦¬ìŠ¤ì™€ ì˜¤ë§Œê³¼ í¸ê²¬ì„ Transition Matrix ë§Œë“œëŠ”ë° ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.

```py
# English Word List
with open('./words.txt', 'r') as f:
    reference = f.readlines()

# War and Peace    
with open('./warandpeace.txt') as f:
    reference += f.readlines()

# Alice Wonderland    
with open('./alicewonderland.txt') as f:
    reference += f.readlines()

# Pride and Prejudice
with open('./prideprejudice.txt') as f:
    reference += f.readlines()

reference = [ln.upper() for ln in reference]
```

ì´ì œ Matrixë¥¼ ì—…ë°ì´íŠ¸ í•´ë´…ì‹œë‹¤!

```py
l = ''

for line in reference:
    for c in line:
        if c in LETTERS:
            trans_mat[c][l] += 1
            l = c
        else:
            if l != '':
                trans_mat[''][l] += 1
            l = ''
```

ë§¤ìš° ê°„ë‹¨í•˜ì£ ? ê³¨ìëŠ” ë§ˆì§€ë§‰ì— ì¶œí˜„í–ˆë˜ ê¸€ìë¥¼ ì˜ë¯¸í•˜ëŠ” `l`ì´ë¼ëŠ” ë³€ìˆ˜ë¡œë¶€í„° í˜„ì¬ ê¸€ìë¥¼ ì˜ë¯¸í•˜ëŠ” `c`ë¡œ ê°€ëŠ” Transition Matrixë¥¼ ë§Œë“œëŠ” ê²ƒì…ë‹ˆë‹¤. ë‹¤ë§Œ ì´ ê¸€ì—ì„œëŠ” ëŒ€ë¬¸ì ì•ŒíŒŒë²³ë§Œ ì‚¬ìš©í•˜ê¸°ë¡œ í–ˆìœ¼ë¯€ë¡œ ê¸°íƒ€ ë‹¨ì–´ëŠ” `''`ë¡œ ì²˜ë¦¬í•´ì£¼ëŠ” ì‘ì—…ì´ ë§ë¶™ì—¬ì§„ ìˆ˜ì¤€ì´ì£ .

ì´ì œ ì—°ì‚°ì„ ì¢€ ë” ì‰½ê²Œ í•˜ê¸° ìœ„í•´ `DataFrame`ìœ¼ë¡œ ë³€í™˜í•´ì¤ë‹ˆë‹¤(ì²˜ìŒë¶€í„° `DataFrame`ì„ ì‚¬ìš©í•˜ì§€ ì•Šì€ ì´ìœ ëŠ” ë¹ˆë²ˆí•˜ê²Œ elementë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ì‘ì—…ì€ Pandasì— ì í•©í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤ğŸ™‚). ë˜í•œ ì¶”ê°€ë¡œ ê° ë¹ˆë„ê°’ìœ¼ë¡œ êµ¬ì„±ëœ Matrixë¥¼ í™•ë¥ ê°’ í˜•íƒœë¡œ ë³€ê²½í•´ì¤¬ìŠµë‹ˆë‹¤.

```py
trans_mat = pd.DataFrame(trans_mat)
trans_prob_mat = (trans_mat + 1).apply(lambda row: row / row.sum(), axis=1)
```

ì, ì´ì œ heatmapì„ í†µí•´ Matrixê°€ ìƒì‹ ìˆ˜ì¤€ì—ì„œ ì˜ ì—…ë°ì´íŠ¸ê°€ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ë³´ì£ .

```py
plt.figure(figsize=(10, 10))
sns.heatmap(trans_prob_mat, cmap='Greys')
```

![](/images/heatmap.png)

ì•ì„œ ì‚¬ìš©í–ˆë˜ ì˜ˆì œì¸ $Q\rightarrow U$ë¡œ ê°€ëŠ” í™•ë¥ ì´ ì•„ì£¼ ë˜ë ·í•˜ì£ ? ì •ìƒì ìœ¼ë¡œ í™•ì¸í–ˆìŠµë‹ˆë‹¤. ì´ì œ ì‹¤ì œ Decrpytioní•´ë³¼ ì°¨ë¡€ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œë„ ì›ê¸€ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ,

```
[A, B, C, ..., X]
```

ìœ„ì™€ ê°™ì€ ì•ŒíŒŒë²³ ë°°ì—´ì„ ë¬´ì‘ìœ„ë¡œ ì„ì–´ ì•„ë˜ì™€ ê°™ì´ ë³€í˜•í•˜ê³  ì´ë¥¼ í†µí•´ `í‰ë¬¸(Plain Text)`ë¥¼ ì•”í˜¸í™”ì‹œí‚µë‹ˆë‹¤.

```
[Z, K, M, ..., A]
```

í‰ë¬¸ ë˜í•œ ì›ê¸€ê³¼ ë™ì¼í•˜ê²Œ <a href="https://math.uchicago.edu/~shmuel/Network-course-readings/MCMCRev.pdf">The Markov Chain Monte Carlo Revolution</a>ê¸€ì—ì„œ ì‚¬ìš©ëœ 

```
ENTER HAMLET HAM TO BE OR NOT TO BE THAT IS THE QUESTION WHETHER TIS NOBLER IN THE MIND TO SUFFER 
THE SLINGS AND ARROWS OF OUTRAGEOUS FORTUNE OR TO TAKE ARMS AGAINST A SEA OF TROUBLES AND BY OPPOSING END
```

ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.

```py
def decode(mapping, coded):
    coded = coded.upper()
    return ''.join([LETTERS[mapping.index(c)] if c in LETTERS else c for c in coded])

def calculate_loglikelihood(decoded):
    l = ''
    log_prob = 0
    mat = trans_prob_mat.loc
    
    for c in decoded:
        if c in LETTERS:
            # if you need to prevent divide by zero exception, 
            # consider to use sys.float_info.epsilon or np.finfo(np.float64).eps
            log_prob += np.log(mat[l, c])
            l = c
        else:
            log_prob += np.log(mat[l, ''])
            l = ''
            
    if l != '':
        log_prob += np.log(mat[l, ''])

    return log_prob
```

ê°„ëµí•˜ê²Œ ì½”ë“œë¥¼ ì„¤ëª…í•˜ìë©´ ì•ì„œ ë§Œë“  Transition Probabilty Matrixì—ì„œ ê¸€ìì—ì„œ ê¸€ìì˜ ì „ì´ì‹œì ì˜ í™•ë¥ ë“¤ì„ ê°€ì ¸ì™€ ê·¸ ê°’ì— logë¥¼ ì”Œìš°ê³  í•©ì‚°, ì „ì²´ ë¬¸ì¥ì˜ log liklihoodì˜ í•©ì„ ë°˜í™˜í•˜ë„ë¡ í•©ë‹ˆë‹¤.

(ì£¼ì„ì—ë„ ë‚¨ê²¨ë’€ì§€ë§Œ, logë¥¼ ì·¨í•  ë•ŒëŠ” 0ì´ë©´ -infê°€ ë¦¬í„´ë˜ë¯€ë¡œ í•„ìš” ì‹œ `sys.float_info.epsilon`ì´ë‚˜, `np.finfo(dtype).eps`ë¡œ 0ì´ ì•„ë‹ˆë„ë¡ ë§Œë“¤ì–´ì£¼ì„¸ìš”. )

ì´ì œ ì‹¤ì œ í…ŒìŠ¤íŠ¸í•´ë´…ì‹œë‹¤.

```py
plain_text = 'ENTER HAMLET HAM TO BE OR NOT TO BE THAT IS THE QUESTION WHETHER TIS NOBLER IN THE MIND TO SUFFER'\
'THE SLINGS AND ARROWS OF OUTRAGEOUS FORTUNE OR TO TAKE ARMS AGAINST A SEA OF TROUBLES AND BY OPPOSING END'

key = random.sample(LETTERS, len(LETTERS))
coded = decode(key, plain_text)

iters = 5000

mapping = random.sample(LETTERS, len(LETTERS))
max_decode = cur_decode = decode(mapping, coded)
max_loglike = cur_loglike = calculate_loglikelihood(cur_decode)

for i in range(iters):
    p1, p2 = random.choices(range(len(mapping)), k=2)    
    prop_mapping = mapping.copy()
    prop_mapping[p1] = mapping[p2]
    prop_mapping[p2] = mapping[p1]

    prop_decode = decode(prop_mapping, coded)
    prop_loglike = calculate_loglikelihood(prop_decode)
    
    if random.random() < np.exp(prop_loglike - cur_loglike):
        mapping = prop_mapping
        cur_decode = prop_decode
        cur_loglike = prop_loglike
        
        if cur_loglike > max_loglike:
            max_loglike = cur_loglike
            max_decode = cur_decode
            
            
    print(cur_decode, end='\r', flush=True)
```

ìœ„ì˜ ì½”ë“œëŠ” ì•½ 5ì²œë²ˆì„ ëŒë©´ì„œ í¬ê²Œ ë‘ê°€ì§€ ì‘ì—…ì„ í•©ë‹ˆë‹¤.

1. ì´ˆê¸°í™”ëœ mappingì´ë¼ëŠ” ë³€ìˆ˜ì—ì„œ ë¬´ì‘ìœ„ë¡œ 2ê°œì˜ ì•ŒíŒŒë²³ì„ ê³¨ë¼, ìœ„ì¹˜ë¥¼ ë°”ê¾¸ê³  ê·¸ë¬ì„ ë•Œ log likelihoodê°€ ì–¼ë§ˆë‚˜ ë˜ëŠ”ì§€ ê³„ì‚°í•˜ëŠ” ì‘ì—…
2. ê·¸ ê°’(`prop_loglike`)ê³¼ íŠ¹ì •ì„ê³„ë¥¼ ë„˜ê¸´ log likelihood(`cur_loglike`)ê°’ì˜ ì°¨ê°€ íŠ¹ì •ì„ê³„ì (`random.random`)ì„ ë„˜ê²¼ëŠ”ì§€ ë¹„êµí•˜ê³  `cur_loglike`ê°’ì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ì‘ì—….

ì´ ì‘ì—…ì„ ê±°ì¹˜ë©´ ë‹¤ìŒê³¼ ìœ ì‚¬í•œ ê²°ê³¼ë¬¼ì„ íšë“í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

```
ENTER HADLET HAD TO PE OR NOT TO PE THAT IS THE KUESTION WHETHER TIS NOPLER IN THE DING TO SUFFERTHE SLINCS ANG ARROWS OF OUTRACEOUS FORTUNE OR TO TAVE ARDS ACAINST A SEA OF TROUPLES ANG PY OMMOSINC ENG
```

**ë²ˆì™¸**

* Python ì˜®ê²¨ì˜¨ ì½”ë“œëŠ” ì–´ë–¤ ì´ìœ ì—ì„œì¸ì§€ Rì—ì„œ ëŒë¦´ ë•Œë³´ë‹¤ Performanceê°€ ë–¨ì–´ì§‘ë‹ˆë‹¤. ì˜ˆìƒí‚¤ë¡œ <a href="https://docs.python.org/ko/3.8/tutorial/floatingpoint.html">Precision ì´ìŠˆ</a>ê°€ ì•„ë‹ê¹Œ ì‹¶ìŠµë‹ˆë‹¤.
* Optimal iterationì´ ìˆì„ê¹Œ 50,000ë²ˆ ë°˜ë³µ í›„ ê·¸ë˜í”„ë¥¼ ê·¸ë ¤ë´¤ëŠ”ë°, ì´ˆê¸° 2,000 ~ 5,000ë²ˆ iterationì—ì„œ log likelihoodê°€ ê¸‰ê²©í•˜ê²Œ ì˜¬ë¼ê°„ í›„ ê±°ì˜ ë¹„ìŠ·í•œ í˜•íƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤(ì•„ë˜ ê·¸ë˜í”„ ì°¸ê³ , xì¶• iteration yì¶• log liklihood)

![](/images/loglikelihood.png)